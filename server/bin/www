#!/usr/bin/env node

var app = require('../app');
var debug = require('debug')('learning:server');
var http = require('http');
var { Server } = require('socket.io');
const mediasoup = require('mediasoup');  // <<== ADD THIS

const server = http.createServer(app);
const io = new Server(server, {
  cors: { origin: 'http://localhost:3000', credentials: true }
});

const userSocketMap = {};
const db = require('../db');

// --- your existing chat helper ---
function removeUserBySocketId(id) {
  for (const [user, sockId] of Object.entries(userSocketMap)) {
    if (sockId === id) {
      delete userSocketMap[user];
      break;
    }
  }
}

// --- mediasoup setup ---
let worker;
let router;
let broadcasterTransport;
let producer;
let consumers = [];

(async () => {
  worker = await mediasoup.createWorker();
  router = await worker.createRouter({ mediaCodecs: [
    {
      kind: 'audio',
      mimeType: 'audio/opus',
      clockRate: 48000,
      channels: 2,
    },
    {
      kind: 'video',
      mimeType: 'video/VP8',
      clockRate: 90000,
      parameters: {},
    },
  ]});
})();

io.on('connection', socket => {
  console.log('New socket connected:', socket.id);

  // --- CHAT handling (already working) ---
  socket.on('register_user', username => {
    console.log('>>> [server] register_user for', username);
    userSocketMap[username] = socket.id;
  });

  socket.on('send_message', async ({ sender, receiver, message }) => {
    console.log('>>> [server] send_message payload:', sender, receiver, message);
    try {
      await db.query(
        'INSERT INTO messages (sender, receiver, message) VALUES (?, ?, ?)',
        [sender, receiver, message]
      );
      const toSocket = userSocketMap[receiver];
      if (toSocket) {
        io.to(toSocket).emit('new_message', { sender, message });
      }
    } catch (err) {
      console.error('Error in send_message handler:', err);
    }
  });

  socket.on('disconnect', () => {
    removeUserBySocketId(socket.id);
  });

  // --- VIDEO Q&A handling (new) ---
  socket.on('getRtpCapabilities', (callback) => {
    callback(router.rtpCapabilities);
  });

  socket.on('createProducerTransport', async (callback) => {
    const transport = await router.createWebRtcTransport({ listenIps: [{ ip: '127.0.0.1', announcedIp: null }] });
    broadcasterTransport = transport;
    callback({
      id: transport.id,
      iceParameters: transport.iceParameters,
      iceCandidates: transport.iceCandidates,
      dtlsParameters: transport.dtlsParameters,
    });

    transport.on('dtlsstatechange', dtlsState => {
      if (dtlsState === 'closed') transport.close();
    });
  });

  socket.on('connectProducerTransport', async ({ dtlsParameters }, callback) => {
    await broadcasterTransport.connect({ dtlsParameters });
    callback();
  });

  socket.on('produce', async ({ kind, rtpParameters }, callback) => {
    producer = await broadcasterTransport.produce({ kind, rtpParameters });
    callback({ id: producer.id });

    producer.on('transportclose', () => producer.close());
  });

  socket.on('createConsumerTransport', async (callback) => {
    const transport = await router.createWebRtcTransport({ listenIps: [{ ip: '127.0.0.1', announcedIp: null }] });
    consumers.push({ transport });
    callback({
      id: transport.id,
      iceParameters: transport.iceParameters,
      iceCandidates: transport.iceCandidates,
      dtlsParameters: transport.dtlsParameters,
    });

    transport.on('dtlsstatechange', dtlsState => {
      if (dtlsState === 'closed') transport.close();
    });
  });

  socket.on('connectConsumerTransport', async ({ dtlsParameters, transportId }, callback) => {
    const consumerTransport = consumers.find(t => t.transport.id === transportId).transport;
    await consumerTransport.connect({ dtlsParameters });
    callback();
  });

  socket.on('consume', async ({ rtpCapabilities, transportId }, callback) => {
    if (!router.canConsume({ producerId: producer.id, rtpCapabilities })) {
      console.error('Cannot consume');
      return;
    }
    const consumerTransport = consumers.find(t => t.transport.id === transportId).transport;
    const consumer = await consumerTransport.consume({
      producerId: producer.id,
      rtpCapabilities,
      paused: false,
    });
    callback({
      id: consumer.id,
      producerId: producer.id,
      kind: consumer.kind,
      rtpParameters: consumer.rtpParameters,
    });
  });
});

// --- server listen ---
var port = normalizePort(process.env.PORT || '8080');
app.set('port', port);

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

// --- helpers (unchanged) ---
function normalizePort(val) {
  var port = parseInt(val, 10);
  if (isNaN(port)) return val;
  if (port >= 0) return port;
  return false;
}

function onError(error) {
  if (error.syscall !== 'listen') throw error;
  var bind = typeof port === 'string' ? 'Pipe ' + port : 'Port ' + port;
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
    default:
      throw error;
  }
}

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string' ? 'pipe ' + addr : 'port ' + addr.port;
  debug('Listening on ' + bind);
}
